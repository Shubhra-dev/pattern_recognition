# -*- coding: utf-8 -*-
"""Copy of Dataset_Processing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RAVLAXMQOTi0VeM8vvzvAASUGDcNFG6v

**Loading your dataset from uploaded csv file**
"""

from google.colab import drive
drive.mount('/content/drive')

from numpy import genfromtxt
data_path = '/content/drive/MyDrive/AI/iris.csv'
iris_data = genfromtxt(data_path, delimiter=',')

#my_data.shape
type(iris_data)

data = iris_data.tolist()
# for i in range(len(data)):
#   print(data[i])

for row in iris_data:
  print(row)
type(data)

!pip install operator
import operator
from operator import itemgetter, attrgetter
import random
import math


random.shuffle(iris_data)

train=[]
validation=[]
test=[]


for i in range(150):
  randomValue = random.uniform(0,1)
  if (randomValue  >= 0 and randomValue <=0.7):
    train.append(iris_data[i])
  elif (randomValue  > 0.7 and randomValue <=0.85):
    validation.append(iris_data[i])
  else :
    test.append(iris_data[i])

kTable=[]

for k in range(15):
  if (k==1 or k==3 or k==5 or k==10 or k==15):
    distanceList=[]
    correct=0
    totalSample=0
    for s in validation:
      totalSample+=1
      trainingIndex = 0
      for v in train: 
        euclidDistance= math.sqrt((s[0]-v[0])**2 +(s[1]-v[1])**2 + (s[2]-v[2])**2 + (s[3]-v[3])**2 )
        thisDict = {
           "dist" : euclidDistance,
           "index" : trainingIndex
        }
    distanceList.append(thisDict)   
    trainingIndex+=1
    
    sorted(thisDict, key =Itemgetter('dist'), reverse= True)
    
    majority = [0,0,0]
    for i in range (k):
        if (train[distanceList[i]['index']][4]==0):
         majority[0]+=1
        elif (train[distanceList[i]['index']][4]==1):
         majority[1]+=1
        else:
         majority[2]+=1
    result = majority.index(max(majority))
    if (result == s[4]):
      correct+=1

    accuracy= correct/totalSample * 100
    kTableDict={
       "value" : k,
       "Accuracy" : accuracy
    }
    kTable.append(kTableDict)

sorted(kTable,Itemgetter(key='Accuracy'),reverse=True)
for i in kTable:
  print(i['value'],"-------",i['Accuracy'])

accurateK = kTable[4]['value']

for s in test:
   sampleIndex = 0;
   for v in train: 
     euclidDistance= math.sqrt((s[0]-v[0])**2 +(s[1]-v[1])**2 + (s[2]-v[2])**2 + (s[3]-v[3])**2 )
     thisDict = {
         "dist" : euclidDistance,
         "index" : sampleIndex
     }
     distanceList.append(thisDict)   
     sampleIndex += 1

   sorted(thisDict,key=Itemgetter('dist'),reverse=true)
   majority = [0,0,0]
   for i in range (accurateK):
      if (train[distanceList[i]['index']][4]==0):
         majority[0]+=1
      elif (train[distanceList[i]['index']][4]==1):
         majority[1]+=1
      else:
         majority[2]+=1


Finalresult = majority.index(max(majority))
print("The calculated result:", Finalresult)
print("The Actual result:", s[4])

